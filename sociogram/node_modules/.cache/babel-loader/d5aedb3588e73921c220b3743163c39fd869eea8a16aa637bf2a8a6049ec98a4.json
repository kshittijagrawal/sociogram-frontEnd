{"ast":null,"code":"// view connect middleware\nvar autoindex = require('./autoindex');\nvar parseUrlAsView = require('./parseUrlAsView');\nmodule['exports'] = function (options) {\n  options.prefix = options.prefix || '';\n  return function routeRequest(req, res, next) {\n    if (options.view) {\n      //\n      // If the view was mounted with a prefix and that prefix was not found in the incoming url,\n      // do not attempt to use that view\n      //\n      // console.log(req.url.blue, 'prefix', options.prefix)\n      if (options.prefix.length > 0 && req.url.search(options.prefix) === -1) {\n        return next();\n      }\n      var _view = options.view;\n      var _baseView = options.baseView;\n      _view = parseUrlAsView(req, _view);\n\n      /*\n        // TODO: uncomment out next block\n        req.resource = req.resource || {};\n        req.resource._args = parts;\n        req.resource.args = parts.slice(foundViews - 1, parts.length);\n      */\n\n      if (typeof _view === \"undefined\") {\n        return missingViewHandler();\n        // TODO: uncomment out next block\n        /* \n           Note: will jump back to previous level of view on 404 \n                 this is needed for regex route parsing\n          if (typeof previousView !== \"undefined\") {\n            _view = previousView.index;\n          } else {\n            return missingViewHandler();\n          }\n        */\n      }\n\n      // TODO: route parsing\n      /*\n      var Route = require('route-parser');\n      // if a Hook.path is defined and there is a wildcard route present\n      if (typeof _view.presenter.route !== \"undefined\" && _view.presenter.route.length > 0 \n         && typeof req.params[\"0\"] !== \"undefined\" && req.params[\"0\"].length > 0) {\n         // attempt to match wildcard route ( recieved after /:owner/:hook/* ) against Hook.path\n         var route = new Route(req.hook.path);\n         var routeParams = route.match(\"/\" + req.params[\"0\"]);\n         // if no route match is found, 404 with a friendly error\n         if (routeParams === false) {\n           res.writeHead(404);\n           // TODO: make error customizable\n           res.end('Invalid path: ' + req.params[\"0\"] + ' does not match ' + req.hook.path);\n           return;\n         }\n         // route matches, map route parameters to resource scope\n         for (var p in routeParams) {\n           req.resource.params[p] = routeParams[p];\n         }\n      }\n      */\n\n      // Note: presenters are currently required for view middleware\n      // this could be changed easily by adding an additional method for default html rendering\n      if (typeof _view.present !== 'function') {\n        return missingViewHandler();\n      }\n      var __view,\n        _template = _view.template;\n      var _layout = _view.layout;\n      if (typeof _baseView !== \"undefined\") {\n        _baseView = parseUrlAsView(req.url, _baseView, false);\n        // console.log('found a baseView to extend', _baseView)\n        if (typeof _baseView !== \"undefined\" && typeof _baseView.presenter !== \"undefined\" && typeof _view.presenter === \"undefined\") {\n          __view = _view;\n          __view.presenter = _baseView.presenter;\n        } else {\n          __view = _view;\n        }\n      } else {\n        __view = _view;\n      }\n      __view.present({\n        request: req,\n        response: res,\n        req: req,\n        res: res,\n        unauthorizedRoleAccess: options.unauthorizedRoleAccess,\n        checkRoleAccess: options.checkRoleAccess,\n        data: req.resource.params\n      }, function (err, rendered) {\n        if (err) {\n          if (err.code === \"NO_PRESENTER_FOUND\" && options.view.autoindex) {\n            return autoindex(__view, {\n              request: req,\n              response: res,\n              req: req,\n              res: res,\n              data: req.resource.params\n            }, function (err, html) {\n              res.end(html);\n            });\n          }\n          return res.end(err.message);\n        } else {\n          res.end(rendered);\n        }\n      });\n    } else {\n      //\n      // No view was found, do not use middleware\n      //\n      missingViewHandler();\n    }\n    function missingViewHandler() {\n      // If we hit a missing view and autoindex is enabled, and we actually have a view to autoindex\n      // Note: in most cases, it seems this is already taken care of...\n      // ...we could probably refactor and remove the following block\n      // console.log('missingViewHandler', req.url);\n      if (options.view.autoindex && typeof _view === \"object\") {\n        //var resp = Object.keys(_view.views);\n        return autoindex(_view, {\n          request: req,\n          response: res,\n          req: req,\n          res: res,\n          data: req.resource.params,\n          unauthorizedRoleAccess: options.unauthorizedRoleAccess,\n          checkRoleAccess: options.checkRoleAccess\n        }, function (err, html) {\n          res.end(html);\n        });\n\n        //return res.end(JSON.stringify(resp, true, 2));\n      } else {\n        // Remark: Simply move forward to the next middleware on the on the express stack\n        next();\n      }\n    }\n    ;\n  };\n};","map":{"version":3,"names":["autoindex","require","parseUrlAsView","module","options","prefix","routeRequest","req","res","next","view","length","url","search","_view","_baseView","baseView","missingViewHandler","present","__view","_template","template","_layout","layout","presenter","request","response","unauthorizedRoleAccess","checkRoleAccess","data","resource","params","err","rendered","code","html","end","message"],"sources":["/Users/ayanyadav/node_modules/view/lib/middle.js"],"sourcesContent":["// view connect middleware\nvar autoindex = require('./autoindex');\nvar parseUrlAsView = require('./parseUrlAsView');\nmodule['exports'] = function (options) {\n  options.prefix = options.prefix || '';\n  return function routeRequest (req, res, next) {\n    if (options.view) {\n      //\n      // If the view was mounted with a prefix and that prefix was not found in the incoming url,\n      // do not attempt to use that view\n      //\n      // console.log(req.url.blue, 'prefix', options.prefix)\n      if (options.prefix.length > 0 && req.url.search(options.prefix) === -1) {\n        return next();\n      }\n      var _view = options.view;\n      var _baseView = options.baseView;\n\n      _view = parseUrlAsView(req, _view)\n\n      /*\n        // TODO: uncomment out next block\n        req.resource = req.resource || {};\n        req.resource._args = parts;\n        req.resource.args = parts.slice(foundViews - 1, parts.length);\n      */\n\n      if (typeof _view === \"undefined\") {\n        return missingViewHandler();\n        // TODO: uncomment out next block\n        /* \n           Note: will jump back to previous level of view on 404 \n                 this is needed for regex route parsing\n          if (typeof previousView !== \"undefined\") {\n            _view = previousView.index;\n          } else {\n            return missingViewHandler();\n          }\n        */\n      }\n\n      // TODO: route parsing\n      /*\n      var Route = require('route-parser');\n      // if a Hook.path is defined and there is a wildcard route present\n      if (typeof _view.presenter.route !== \"undefined\" && _view.presenter.route.length > 0 \n         && typeof req.params[\"0\"] !== \"undefined\" && req.params[\"0\"].length > 0) {\n         // attempt to match wildcard route ( recieved after /:owner/:hook/* ) against Hook.path\n         var route = new Route(req.hook.path);\n         var routeParams = route.match(\"/\" + req.params[\"0\"]);\n         // if no route match is found, 404 with a friendly error\n         if (routeParams === false) {\n           res.writeHead(404);\n           // TODO: make error customizable\n           res.end('Invalid path: ' + req.params[\"0\"] + ' does not match ' + req.hook.path);\n           return;\n         }\n         // route matches, map route parameters to resource scope\n         for (var p in routeParams) {\n           req.resource.params[p] = routeParams[p];\n         }\n      }\n      */\n\n      // Note: presenters are currently required for view middleware\n      // this could be changed easily by adding an additional method for default html rendering\n      if (typeof _view.present !== 'function') {\n        return missingViewHandler();\n      }\n\n      var __view, _template = _view.template;\n      var _layout = _view.layout;\n      if (typeof _baseView !== \"undefined\") {\n        _baseView = parseUrlAsView(req.url, _baseView, false);\n        // console.log('found a baseView to extend', _baseView)\n        if (typeof _baseView !== \"undefined\" && typeof _baseView.presenter !== \"undefined\" && typeof _view.presenter === \"undefined\") {\n          __view = _view;\n          __view.presenter = _baseView.presenter;\n        } else {\n          __view = _view;\n        }\n      } else {\n        __view = _view;\n      }\n\n      __view.present({\n        request: req,\n        response: res,\n        req: req,\n        res: res,\n        unauthorizedRoleAccess: options.unauthorizedRoleAccess,\n        checkRoleAccess: options.checkRoleAccess,\n        data: req.resource.params\n        }, function (err, rendered) {\n          if (err) {\n            if (err.code === \"NO_PRESENTER_FOUND\" && options.view.autoindex) {\n              return autoindex(__view, {\n                request: req,\n                response: res,\n                req: req,\n                res: res,\n                data: req.resource.params\n              }, function (err, html){\n                res.end(html);\n              });\n            }\n            return res.end(err.message);\n          } else {\n            res.end(rendered);\n          }\n      });\n    } else {\n      //\n      // No view was found, do not use middleware\n      //\n      missingViewHandler();\n    }\n\n    function missingViewHandler () {\n      // If we hit a missing view and autoindex is enabled, and we actually have a view to autoindex\n      // Note: in most cases, it seems this is already taken care of...\n      // ...we could probably refactor and remove the following block\n      // console.log('missingViewHandler', req.url);\n      if (options.view.autoindex && typeof _view === \"object\") {\n        //var resp = Object.keys(_view.views);\n        return autoindex(_view, {\n          request: req,\n          response: res,\n          req: req,\n          res: res,\n          data: req.resource.params,\n          unauthorizedRoleAccess: options.unauthorizedRoleAccess,\n          checkRoleAccess: options.checkRoleAccess\n        }, function (err, html){\n          res.end(html);\n        });\n\n        //return res.end(JSON.stringify(resp, true, 2));\n      } else {\n        // Remark: Simply move forward to the next middleware on the on the express stack\n        next();\n      }\n    };\n\n  };\n\n};"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}